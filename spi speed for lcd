Great question — this matters **a lot** once you move beyond libraries.

I’ll give you the **practical answer**, the **datasheet answer**, and the **system-level way to choose SPI speed**, especially relevant if you’re thinking CPU / FPGA / custom logic.

---

# SPI Speed for ST7789 (1.14″ TFT)

## Short, safe answer (memorize this)

> **4–8 MHz is safe on almost every 1.14″ ST7789 module**
> **10–20 MHz often works**
> **>20 MHz depends on wiring, board, and luck**

If you want **zero surprises**:

* Use **4 MHz** first
* Increase gradually

---

## What the ST7789 Actually Supports (Datasheet Reality)

From the ST7789 controller specs (SPI, write mode):

* **Maximum SPI clock**: ~**62.5 MHz** (theoretical internal limit)
* **Practical external limit**:

  * Usually **10–20 MHz**
  * Often lower on breakout boards

Why the huge gap?

* Datasheet assumes:

  * Perfect PCB
  * Short traces
  * Controlled impedance
* Breakout modules violate all of that

---

## Why SPI Speed Matters Physically

SPI is **not packetized**.
Every pixel bit must arrive **cleanly and on time**.

At high speed:

* Clock skew
* Ringing
* Setup/hold violations
* MOSI transitions sampled wrong

Symptoms of too-fast SPI:

* Random pixel corruption
* Wrong colors
* Vertical/horizontal artifacts
* Occasional “shifted” frames
* Works at room temp, fails when warm

---

## Real-World Tested Ranges

| SPI Clock | Status                   | Notes                  |
| --------- | ------------------------ | ---------------------- |
| 1–2 MHz   | Extremely safe           | Slow refresh           |
| 4 MHz     | **Recommended baseline** | Rock solid             |
| 8 MHz     | Very common              | Used by many libraries |
| 10–12 MHz | Often OK                 | Depends on wiring      |
| 16 MHz    | Borderline               | Short wires only       |
| 20 MHz    | Risky                    | Good PCB required      |
| >20 MHz   | Rarely stable            | FPGA + PCB only        |

---

## Throughput Reality (Important Insight)

### Frame size

```
135 × 240 × 16 bits = 518,400 bits ≈ 64.8 KB
```

### Time to send one full frame

| SPI Speed | Full Frame Time |
| --------- | --------------- |
| 4 MHz     | ~130 ms         |
| 8 MHz     | ~65 ms          |
| 16 MHz    | ~32 ms          |

That’s **just raw transfer**, not counting commands.

This is why:

* Full-screen redraws are slow
* Partial updates matter
* Hardware scrolling exists

---

## Command vs Pixel Speed

Important detail:

* **Commands do not need high speed**
* **Pixel streaming does**

Best practice:

* Same SPI speed for simplicity
* Or:

  * Low speed during init
  * High speed during RAMWR

(Advanced systems sometimes do this)

---

## SPI Speed vs DC Pin Timing

At high speed:

* **DC must be stable before the first clock**
* No glitches allowed
* FPGA users: register DC, don’t combinatorially drive it

---

## If You’re Designing a CPU / FPGA (Your Context)

Since you’ve been talking about:

* Building CPUs
* Framebuffers
* FPGA logic

### Recommended design values

* SPI clock: **8 MHz**
* CS asserted for entire transaction
* DC registered
* MOSI registered
* One byte per 8 clocks, no gaps

If you want to push speed:

* Pipeline bytes
* No CS toggling between pixels
* Keep traces short

---

## Why Some Displays “Work” at Crazy Speeds

Sometimes you’ll see:

> “I run it at 40 MHz and it works”

Reasons:

* Very short wires
* Lucky timing margins
* Temperature-dependent
* Borderline but not yet failing

These systems are **fragile**.

---

## Final Rule of Thumb (Lock This In)

> **Choose the fastest SPI speed that produces ZERO artifacts
> under worst-case conditions**

For most people:

* **8 MHz** is the sweet spot

---

## If you want next (very relevant options)

I can:

* Calculate **required SPI speed for a target FPS**
* Show **how to burst pixels efficiently**
* Explain **why the display refresh is independent of SPI**
* Help you design a **DMA-style SPI engine**

Just tell me which direction you want.
