LD - load value from one register to another
LD [to register], [from register]
```
LD R1, R2
R1 = R2
```

LDR - load value raw into register
LDR [to register], [value]
```
LDR R1, 10
R1 = 10
```
| add support for both int,hex,binary,char
| int - just number
| hex - start with 0x
| binary - start with b
| char - have ' around it

ADD - adds registers
ADD [to register], [with register]
```
ADD R1, R2
R1 = R1 + R2
```

SUB - subtract  registers
SUB [to registers], [with registers]
```
SUB R1, R2
R1 = R1 - R2
```

INC - increments register by one
INC [register to increment]
```
INC R1
R1 = R1 + 1
```

DEC - decrement register by one
DEC [register to decrement]
```
DEC R1
R1 = R1 - 1
```

PSH - push register value on the stack
PSH [from register]
```
PSH R1
[R1 value is now on the stack and the pointer moved]
```

POP - pop last value from the stack to the register
POP [to register]
```
POP R1
[R1 value is the last value on the stack, pointer moves down]
```

JMP - jump to value in jump register
JMP
```
LDR RJ0, 0x01
LDR RJ1, 0xF0
JMP
[jumps to 0xF001]
```

JMR - jump to specific raw value
JMR [value] [value]
```
JMR 0x00, 0x01
[jumps to 0x0001]
```

JMI - jump to value in jump register if flag
JMI [flag] (C - carry, Z - zero)
```
LDR RJ0, 0xA2
LDR RJ1, 0x0E
LDR R0, 1
DEC R0
JMI Z
[jumps to 0x0EA2]
```

```
LDR RJ0, 0xA2
LDR RJ1, 0x0E
LDR R0, 2
DEC R0
JMI Z
[no jump]
```

COM - compares 2 registers doing subtraction but does not save it
COM [register] [register]
```
COM R0, R1
[does R0 - R1 values and only sets relevant flags]
```

memory locations
to allow easier jump address location added memory locations
string starting with '&' ending with ':'
this will point to the instruction right after it
to access it when passing raw value use @ and the name of the memory location
```
&example:
INC R0
LDR RJ @example
[example will be the location of INC R0]
```

specific memory location to start from
[number or hex]
```
LDR R0, 1
[0xa0]
LDR R1, 2
[places the `LDR R1, 2` in memory location 0xa0]
```

CAL - used to call a function, pushes the current pc into stack and jumps to memory location
CAL [memory location]
```
CAL @example
INC R1

&example:
INC R0
```

RTN - pops to the pc
RTN
```
&example:
INC R0
RTN
```

WR - write value to ram
WR [register to get value from]
```
LDR RM0 0
LDR RM1 0
// address 0 in ram
WR R0
[writes R0 value to address 0]
```

RD - read value from ram to register
RD [register to write to]
```
LDR RM0 0
LDR RM1 0
// address 0 in ram
RD R0
[writes value from ram address 0 to R0]
```

CIS - clear interrupt status
```
[after getting interrupt with the call to handle it]
CIS
[returns to where we were before the interrupt and sets the status of the interrupt to 0]
```